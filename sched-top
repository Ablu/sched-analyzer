#!/usr/bin/env python
# PYTHON_ARGCOMPLETE_OK
#
# SPDX-License-Identifier: GPL-2.0
# Copyright (C) 2022 Qais Yousef

import argparse
import pandas as pd
import plotext as plt
import readline
import shlex
import subprocess
import time

# Allow tab completion when giving input
readline.set_completer_delims(' \t\n=')
readline.parse_and_bind("tab:complete")

try:
    import argcomplete
except:
    pass


refresh_rate = 5 # seconds
display_window = 20 #seconds

num_top_tasks = 10

args = None


def parse_cmdline():
    parser = argparse.ArgumentParser(description='''
    sched-top

    Take a peak inside scheduler in top like style.

    CTRL+c to exit.
    ''', formatter_class=argparse.RawTextHelpFormatter)

    parser.add_argument('refresh_rate', type=int, default=5, nargs='?',
                    help='How often to refresh the graphs. Default 5 seconds.')
    parser.add_argument('display_window', type=int, default=20, nargs='?',
                    help='The window of time to display. Default last 20 seconds.')

    group = parser.add_mutually_exclusive_group()
    group.add_argument('--task', type=int, default=10, nargs='?', metavar='N',
                    help='Show util_avg of top N tasks. 10 by default.')
    group.add_argument('--rq', action='store_true',
                    help='Show cfs, rt and dl util_avg for all rqs.')
    group.add_argument('--nr_running', action='store_true',
                    help='Show number of running tasks for all rqs.')

    try:
        argcomplete.autocomplete(parser)
    except:
        pass

    return parser.parse_args()

def show_rq_pelt():

    while True:

        df = pd.read_csv("/tmp/rq_pelt.csv")
        df.ts = df.ts - df.ts[0]
        df.ts = df.ts / 1000000000

        # We read in realtime, last row could end up being partially written.
        # dropping na should address this.
        df.dropna(inplace=True)

        last_ts = df.ts.iloc[-1] - display_window
        df = df[df.ts > last_ts]

        num_cpus = len(df.cpu.unique())
        num_cpus_cols = 2
        num_cpus_rows = int(num_cpus / num_cpus_cols) or 1

        plt.subplots(num_cpus_rows, num_cpus_cols)

        plt.cld()
        for cpu in range(num_cpus):
            df_cpu = df[df.cpu == cpu]

            if df_cpu.empty:
                continue

            row = int(cpu / num_cpus_cols) + 1
            col = cpu % num_cpus_cols + 1
            plt.subplot(row, col)
            df_cfs = df_cpu[df_cpu.type == "cfs"]
            df_rt = df_cpu[df_cpu.type == "rt"]
            df_dl = df_cpu[df_cpu.type == "dl"]
            if num_cpus <= 8:
                plt.plot(df_cfs.ts.values, df_cfs.util.values, label="cfs")
                plt.plot(df_rt.ts.values, df_rt.util.values, label="rt")
                plt.plot(df_dl.ts.values, df_dl.util.values, label="dl")
            else:
                pelt_types = ["cfs", "rt", "dl"]
                pelt_mean = [df_cfs.util.mean(), df_rt.util.mean(), df_dl.util.mean()]
                plt.bar(pelt_types, pelt_mean, orientation="h", width=1/10)
                plt.xlim(0, 1024)
            plt.title("CPU{} util_avg".format(cpu))
            plt.grid(True, True)

        plt.show()
        time.sleep(refresh_rate)

def show_task_pelt():

    while True:

        df = pd.read_csv("/tmp/task_pelt.csv")
        df.ts = df.ts - df.ts[0]
        df.ts = df.ts / 1000000000

        # We read in realtime, last row could end up being partially written.
        # dropping na should address this.
        df.dropna(inplace=True)

        last_ts = df.ts.iloc[-1] - display_window
        df = df[df.ts > last_ts]

        df_top_comms = df.groupby('comm').util.mean().sort_values(ascending=False)

        plt.cld()
        plt.clf()
        for i in range(num_top_tasks):
            comm = df_top_comms.index[i]
            df_comm = df[df.comm == comm]
            plt.plot(df_comm.ts.values, df_comm.util.values, label=comm)
        plt.title("Top {} Tasks util_avg".format(num_top_tasks))
        plt.grid(True, True)

        plt.show()
        time.sleep(refresh_rate)

def show_rq_nr_running():

    while True:

        df = pd.read_csv("/tmp/rq_nr_running.csv")
        df.ts = df.ts - df.ts[0]
        df.ts = df.ts / 1000000000

        # We read in realtime, last row could end up being partially written.
        # dropping na should address this.
        df.dropna(inplace=True)

        last_ts = df.ts.iloc[-1] - display_window
        df = df[df.ts > last_ts]

        num_cpus = len(df.cpu.unique())
        num_cpus_cols = 2
        num_cpus_rows = int(num_cpus / num_cpus_cols) or 1

        plt.subplots(num_cpus_rows, num_cpus_cols)

        plt.cld()
        for cpu in range(num_cpus):
            df_cpu = df[df.cpu == cpu]

            if df_cpu.empty:
                continue

            row = int(cpu / num_cpus_cols) + 1
            col = cpu % num_cpus_cols + 1
            plt.subplot(row, col)
            plt.plot(df_cpu.ts.values, df_cpu.nr_running.values)
        plt.title("CPU{} nr_rnning".format(cpu))
        plt.grid(True, True)

        plt.show()
        time.sleep(refresh_rate)

if __name__ == '__main__':
    args = parse_cmdline()
    refresh_rate = args.refresh_rate
    display_window = args.display_window
    try:
        if args.task:
            num_top_tasks = args.task

        if args.rq:
            show_rq_pelt()

        if args.nr_running:
            show_rq_nr_running()

        # Default view
        show_task_pelt()
    except Exception as e:
        print("Error:", e)
    except KeyboardInterrupt:
        pass

    plt.clt()
